// @ts-nocheck
import { useEffect, useState } from "react";
import spotify, { getAllUserPlaylists } from "../util/spotify";
import "./Playlist.scss";
import "missing-native-js-functions";
import { Popup } from "./Popup";

function millisToMinutesAndSeconds(millis: number) {
	var minutes = Math.floor(millis / 60000);
	var seconds = Math.floor((millis % 60000) / 1000);
	return minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
}

export default function Playlist({
	id,
	playlists: pl,
}: {
	id: string;
	playlists: SpotifyApi.PlaylistObjectSimplified[];
}) {
	const [playlist, setPlaylist] = useState<SpotifyApi.SinglePlaylistResponse | null>(null);
	const artists = new Map<string, SpotifyApi.ArtistObjectFull>();
	const [popup, openPopup] = useState(false);
	const [count, setCount] = useState(0);
	const [minimumSizePlaylist, setMinimumSizePlaylist] = useState(30);
	const [genres, setGenres] = useState<string[]>([]);
	const [excludedGenres, setExcludedGenres] = useState<string[]>([]);
	const [onlyTopGenre, setOnlyTopGenre] = useState(false);
	const [noDuplicates, setNoDuplicates] = useState(true);
	const [progress, setProgress] = useState(false);
	// const [clearPlaylists, setClearPlaylists] = useState(false);
	const [previewUrl, setPreviewUrl] = useState(null);

	const playlists = [...pl];

	async function handleTracks(items: SpotifyApi.PlaylistTrackObject[]) {
		items = items.filter((x) => !!x.track.id); // filter local songs

		var artistIds = items
			.map((x) => x.track.artists.map((y) => y.id))
			.flat()
			.unique()
			// @ts-ignore
			.filter((x) => x && !artists.has(x.id));

		while (artistIds.length) {
			const batch = artistIds.slice(0, 50);
			artistIds = artistIds.slice(50);

			const { body } = await spotify.getArtists(batch);
			body.artists.forEach((x) => artists.set(x.id, x));
		}

		items.forEach(
			(x) =>
				(x.track.genres = x.track.artists
					.map((y) => artists.get(y.id)?.genres || [])
					.flat()
					.unique())
		);
		return items;
	}

	useEffect(() => {
		console.log("fetch playlist");
		spotify.getPlaylist(id, {}).then(async ({ body: state }) => {
			state.tracks.items = await handleTracks(state.tracks.items);
			setPlaylist(state);

			while (state.tracks.next) {
				console.log("fetch tracks", state.tracks);

				const { body: tracks } = await spotify.getPlaylistTracks(id, {
					offset: state.tracks.offset + state.tracks.limit,
				});

				state.tracks = { ...tracks, items: state.tracks.items.concat(await handleTracks(tracks.items)) };

				setPlaylist({ ...state });
			}
		});
	}, [id]);

	async function convert(doCount = false) {
		if (!playlist) return;
		// spotify
		const noGenre = 'undefined';
		const splitRE = /(?: *[,;/] *)+/;
		let allTracks = playlist.tracks.items;
		
		let genres0 = allTracks
			.map((x) => x.track.genres || [])
			.flat()
			.unique();

		let textArea = document.getElementById("textareaId");
		let keywords = textArea.value.split("\n")
			.filter(word => word !== '')
			.unique();
		
		if (keywords.length) {
			genres0 = genres0.map((x) => {
				for (let line of keywords) {
					const words = line.split(splitRE)
						.filter(w => w !== '')
						.unique();
					for (let word of words)
						if(x.match(word)) return line;
				}
				return x;
			});
		}
		genres0.push(noGenre);
		const genres = genres0.unique();
		
		const listGenrePlaylists = [];

		var i = 0;
		const percentage = 100 / count;
		
		
		for (const genre of genres) {
			var songs = allTracks
				.filter((x) => {
					let curGenres = x.track.genres || [];
					if (curGenres.length) {
						if (onlyTopGenre) curGenres.first();
						for (let iter of curGenres) {
							const words = genre.split(splitRE)
								.filter(w => w !== '')
								.unique();
							for (let word of words)
								if(iter.search(word) !== -1) return true;
						}
					} else if (genre == noGenre) return true;
					return false;
				});
				
			if (songs.length < minimumSizePlaylist) continue;
			if (excludedGenres.includes(genre)) {
				listGenrePlaylists.push(genre);
				continue;
			}
			i++;
			listGenrePlaylists.push(genre+' - '+songs.length);
			if (noDuplicates) allTracks = allTracks.filter((x) => !songs.includes(x));
			console.log('allTracks.length='+allTracks.length);
			if (doCount) continue;

			var list = playlists.find((x) => x.name.toLowerCase() === genre.toLowerCase());
			if (!list) {
				list = (await spotify.createPlaylist(genre, { public: false, description: `${genre} autogenerated` }))
					.body;
				playlists.push(list);
			}

			const songPercentage = percentage / (songs.length || 1);
			var j = 1;

			while (songs.length) {
				const batch = songs.slice(0, 100).map((x) => x.track.uri);
				songs = songs.slice(100);
				j += songs.length;

				await spotify.replaceTracksInPlaylist(list.id, batch);
				setProgress(percentage * i * songPercentage * j);
			}

			setProgress(percentage * i);
		}
		setCount(i);
		setGenres(listGenrePlaylists);
	}

	if (!playlist) return <div>Loading playlist ...</div>;

	function toggleGenre(genre) {
		var list = [...excludedGenres];

		if (list.includes(genre)) list = list.filter((x) => x !== genre);
		else list.push(genre);

		setExcludedGenres(list);
	}

	console.log({ previewUrl });

	return (
		<div className="playlist">
			{playlist.tracks.items.length !== playlist.tracks.total && (
				<progress max={playlist.tracks.total} value={playlist.tracks.items.length}></progress>
			)}

			<Popup open={popup} setOpen={openPopup}>
				<h1 style={{ fontSize: "3rem" }}>Separate into genres</h1>
				{count ? (
					<p className="yellow">Warning this will generate {count} new genre playlists</p>
				) : (
					<p>
						Sorry but your playlist is too small,
						<br />
						change the minimum size of genre playlist
					</p>
				)}

				<ul className="genres">
					{genres.map((x) => (
						<li
							onClick={toggleGenre.bind(null, x)}
							style={{ textDecoration: excludedGenres.includes(x) ? "line-through" : "" }}
						>
							{x}
						</li>
					))}
				</ul>
				
				<label>
					<textarea id="textareaId"
					rows="5" cols="33">
					</textarea>
					<br />Combine genres by keywords
				</label>
				
				<label>
					<input
						type="number"
						min="1"
						value={minimumSizePlaylist}
						onChange={(e) => setMinimumSizePlaylist(Number(e.target.value))}
					/>
					<br />
					Minimum size of genre playlist
				</label>

				<label>
					<input type="checkbox" value={onlyTopGenre} onChange={(e) => setOnlyTopGenre(e.target.checked)} />
					Only filter by main genre of song
				</label>

				<label>
					<input type="checkbox" value={noDuplicates} onChange={(e) => setNoDuplicates(e.target.checked)} />
					Do not duplicate songs
				</label>

				{/* <label>
					<input
						type="checkbox"
						value={clearPlaylists}
						onChange={(e) => setclearPlaylists(e.target.checked)}
					/>
					Clear genre playlists
				</label> */}

				<div>
					<button className="button" style={{ fontSize: "0.6rem" }} onClick={() => convert(true)}>
						Recalculate
					</button>
				</div>

				<div>
					<button className="button dark" onClick={() => convert(false)}>
						Separate
					</button>
				</div>

				<div>{progress >= 100 ? "DONE" : progress && <progress max={100} value={progress}></progress>}</div>
			</Popup>

			<div className="info">
				<div className="art">
					<img src={playlist.images.first()?.url} alt="Playlist cover" />
				</div>

				<div className="meta">
					<div className="author">{playlist.owner.display_name}</div>

					<div className="name">{playlist.name}</div>

					<div className="actions">
						<button onClick={() => openPopup(true) || convert(true)} className="button light save">
							Separate into genres
						</button>
					</div>
				</div>
			</div>

			{previewUrl && <audio src={previewUrl} controls autoPlay loop></audio>}

			<table className="tracks">
				<thead className="heading">
					<td className="number">#</td>

					<td className="title">Song</td>
					<td className="genre">Genre</td>

					<td className="length">Length</td>
				</thead>

				<tbody>
					{playlist.tracks.items.map((x, i) => (
						<tr
							onClick={setPreviewUrl.bind(null, x.track.preview_url)}
							className="track"
							key={x.track.id + i + playlist.id}
						>
							<td className="number">{i + 1}</td>

							<td className="title">{x.track.name}</td>
							<td className="genre">
								{x.track.genres.map((x) => (
									<p>{x}</p>
								))}
							</td>

							<td className="length">{millisToMinutesAndSeconds(x.track.duration_ms)}</td>
						</tr>
					))}
				</tbody>
			</table>
		</div>
	);
}
